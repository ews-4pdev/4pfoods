<?php


/**
 * Skeleton subclass for representing a row from the 'user_bag_item' table.
 *
 *
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    propel.generator.ormroot
 */
class UserBagItem extends BaseUserBagItem
{
    public static function createBagsItem($UserBagId, PropelObjectCollection $bagItems)
    {
        if (!is_null($bagItems)) {
            UserBagItemArchiveQuery::create()->filterByBagId($UserBagId)->delete();
            self::deleteBeforeInsert($UserBagId);
            foreach ($bagItems as $bItem) {
                if ($bItem->getStatus() == 'Primary') {
                    $temp = new UserBagItem();
                    $temp->setPoints($bItem->getPoints())
                        ->setBagId($UserBagId)
                        ->setPointId($bItem->getPointId())
                        ->setVersion(0)
                        ->save();
                }
            }
        }
    }

    protected function deleteBeforeInsert($bagId)
    {
        UserBagItemQuery::create()
            ->filterByBagId($bagId)
            ->delete();
    }

    public function validateUserBagItem(User $oUser, Subscription $oSub)
    {
        // Does this bag belongs to current user
        if ($this->getUserBag()->getUserId() != $oUser->getId()) {
            throwSingleError('InvalidBagForCurrentUser');
        }
        // Does this bag and subscription have same Product
        if ($this->getUserBag()->getProductId() != $oSub->getProductId()) {
            throwSingleError('CategoryNotMatch');
        }
        //Also check whether this has valid product
        $oProduct = ProductQuery::create()->findPk($this->getUserBag()->getProductId());
        if (!$oProduct) {
            throwSingleError('InvalidProduct');
        }
    }

    public function bagChanged()
    {
        return UserBagQuery::create()->findPk($this->getBagId())->setIsChanged(true)->save();
    }

    function preSave(PropelPDO $con = null)
    {
//        if (!$this->isColumnModified('user_bag_item.points')
//            && !$this->isColumnModified('user_bag_item.quantity')
//            && !$this->isColumnModified('user_bag_item.status')
//        ) {
//            return parent::preSave($con);
//        }
        if (!$this->validatePoints()) {
            throwSingleError('PointsOverFlow');
        }
        if( count( $this->getItemsWithStatus('Active') ) == 1 && $this->getStatus() == 'Deleted' ){
            throwSingleError('LastItemStanding');
        }
        return parent::preSave($con);
    }

    function preDelete(PropelPDO $con = null)
    {
        // Validate if this the last item than return false
        if( count( $this->getItemsWithStatus('Active') ) == 1 ){
            throwSingleError('LastItemStanding');
        }
        return parent::preDelete($con); // TODO: Change the autogenerated stub
    }

    function getItemsWithStatus($status = null){
        return UserBagItemQuery::create()
                ->filterByBagId( $this->getBagId() )
                ->_if( $status )
                ->filterByStatus('Active')
                ->_endif()
                ->find();
    }

    public function validatePoints()
    {
        // If object is new than simply adding into existing total points would do the trick
        $original_points = (int)UserBagQuery::create()->findPk($this->getBagId())->getTotalPoints();
        $original_points += BagsPeer::EXTRA_POINTS;
        // Add extra points allowed by admin
        if ($this->isNew()) {
            $points = $this->getTotalPoints() + ($this->getQuantity() * $this->getPoints());
            if ($points > $original_points) {
                return false;
            }
        } else {
            // If not new than need to figure out whether this is increase points or decrease points
            $totalPoints = 0;
            if ( $this->isColumnModified('user_bag_item.status') && $this->getStatus() == 'Active' ) {
                $totalPoints = (int)$this->getTotalPoints() + (int)($this->getPoints() * $this->getQuantity());
            } else {

                $items = UserBagItemQuery::create()
                    ->filterByBagId($this->getBagId())
                    ->filterByStatus('Active')
                    ->find();
                foreach ($items as $item) {
                    if ($item->getId() == $this->getId()) {
                        $totalPoints = $totalPoints + ($this->getQuantity() * $this->getPoints());
                    } else {
                        $totalPoints = $totalPoints + ($item->getQuantity() * $item->getPoints());
                    }
                }
            }

            if ($totalPoints > $original_points) {
                return false;
            }
        }
        return true;
    }

    public function getTotalPoints()
    {
        return UserBagItemQuery::create()
            ->filterByBagId($this->getBagId())
            ->filterByStatus('Active')
            ->withColumn('SUM( quantity * points )', 'total_points')
            ->select('total_points')
            ->findOne();
    }

}
